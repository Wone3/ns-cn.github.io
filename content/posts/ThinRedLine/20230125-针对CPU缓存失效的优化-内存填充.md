---
title: "针对CPU缓存失效的优化 内存填充"
date: 2023-01-25T13:41:54+08:00
draft: true
tags: [OpenSource,Java,ThinRedLine]
categories: [ThinRedLine]
---

## 缓存行和缓存行填充

> 参考文章：[剖析Disruptor:为什么会这么快？（二）神奇的缓存行填充](http://ifeve.com/disruptor-cacheline-padding/)

## 代码示例

指定并发线程数量，并发修改全局静态数据的数据，对比不同填充类型下运行同一代码逻辑的耗时

> 本示例代码样例：[ns-cn/MemPadding](https://github.com/ns-cn/MemPadding)

### Java版本代码说明

> Java版本样例：[ns-cn/MemPadding/tree/main/Java](https://github.com/ns-cn/MemPadding/tree/main/Java)，依赖shell环境和JDK

提供了编译运行的脚本

```shell
./Padding [type [thread-num]]
```

|参数|说明|
|:---:|---|
|type|内存填充类型，可选(不填充选0、手动填充选1、自动填充选2)|
|thread-num|线程数量，可选，默认为10|

#### 不填充

以不填充的方式运行代码示例，并发线程数量为4

```shell
./Padding.sh 0 4
```

#### 手动填充

以手动填充的的方式运行代码示例，并发线程数量为4

```shell
./Padding.sh 1 4
```

#### 自动填充

以手动填充的的方式运行代码示例，并发线程数量为4

```shell
./Padding.sh 2 4
```

## 运行结果对比

> 本结果运行环境:
>
> 硬件：MacBook Pro 15-inch, 2018（2.6 GHz 六核Intel Core i7、16GB 2400 MHz DDR4）
>
> 操作系统：Ventura 13.1
>
> JDK：1.8.0_352`OpenJDK 64-Bit Server VM (Zulu 8.66.0.15-CA-macosx) (build 25.352-b08, mixed mode)`

|方案|线程数|线程耗时|运行结果|
|---|:---:|:---:|---|
|不填充|4|45607|`170.26s user 4.40s system 382% cpu 45.700 total`|
|手动填充|4|5085|`19.21s user 0.45s system 380% cpu 5.173 total`|
|自动填充|4|5009|`19.14s user 0.43s system 383% cpu 5.102 total`|
