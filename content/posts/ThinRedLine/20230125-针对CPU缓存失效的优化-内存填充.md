---
title: "针对CPU缓存未命中的优化-内存填充"
date: 2023-01-25T13:41:54+08:00
draft: true
tags: [OpenSource,Java,ThinRedLine]
categories: [ThinRedLine]
---

## 一、缓存行和缓存行填充

> 参考文章：[剖析Disruptor:为什么会这么快？（二）神奇的缓存行填充](http://ifeve.com/disruptor-cacheline-padding/)

### 1.1 CPU多级缓存

越靠近CPU内存越小但速度越快，三级缓存L3被单个插槽上的所有CPU核共享；主存由所有插槽的CPU核共享。
查找所需数据的顺序：`L1 -> L2 -> L3 -> 主存`，走得越远耗时越长。

![CPU多级缓存与内存的关系图](http://ifeve.com/wp-content/uploads/2013/01/CPUCache.png)

> CPU缓存命中耗时参考,Martin和Mike的[QCon presentation](http://www.infoq.com/presentations/LMAX)演讲中

|从CPU到|大约需要的CPU周期|大约需要的时间|
|---|---|---|
|主存||约60-80纳秒|
|QPI 总线传输||约20纳秒|
|L3 Cache|约40-45 cycles|约15纳秒|
|L2 Cache|约10 cycles|约3纳秒|
|L1 Cache|约3-4 cycles|约1纳秒|
|寄存器|1 cycle||

### 1.2 缓存行

缓存是由缓存行组成的，通常是64字节（比较旧的处理器缓存行是32字节）。一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。

> - 数组类型：连续加载，可以快速遍历；非彼此相邻的数据结构（例如链表）：每一项都可能会出现缓存未命中。
> - 一个类中的多个单独变量，在内存中紧挨着，加载其中一个变量时其他变量也会加载

![类中对象的属性的连续加载](http://ifeve.com/wp-content/uploads/2013/01/FalseSharing.png)

### 1.3 伪共享问题

CPU1和CPU2缓存都有AB数据，只要一方修改了A或者B，就会导致对方缓存数据失效，虽然保证了缓存一致性，却失去的一定的性能。这就是所谓的**伪共享问题**。

> 参考文章：[CPU任务调度和伪共享问题小结](https://blog.csdn.net/shark_chili3007/article/details/108340940)

1. CPU核心1从主存中加载一个缓存行，并标记该缓存行的独占状态`E`。
2. CPU核心2也加载了同样地址的内存数据，在总线(BUS)上发了消息问问有没有CPU加载过该数据，发现CPU核心1有加载，于是CPU们都把这个数据设置为共享状态`S`。
3. CPU1改了变量A B的数据，发出了通知，CPU2知道之后，就将自己cache line中的数据设置为无效I。CPU1就将这个数据的状态标志设置为修改`M`。
4. 然后CPU2也要改数据了，他发现自己cache line中的数据无效了，所以需要CPU1把修改的数据写回内存，CPU2去内存中捞出来改，然后CPU将改完的数据设置为M。CPU1将当前cache line中的数据设置为I(无效)。

![CPU1加载一个缓存行](https://img-blog.csdnimg.cn/e8d576cce9f14847a1a84d1374b63f3a.png)
![CPU2加载同一缓存行数据](https://img-blog.csdnimg.cn/747676442d704f52b2c8e1e2fbcdfbd0.png)
![CPU1修改数据](https://img-blog.csdnimg.cn/840340297887427fbd03e43ed75c7f11.png)

### 1.4 解决方案－缓存行填充

通过增加补全来确保ring buffer的序列号不会和其他东西同时存在于一个缓存行中。因此没有伪共享，就没有和其它任何变量的意外冲突，没有不必要的缓存未命中。

```java
public long p1, p2, p3, p4, p5, p6, p7; // cache line padding
private volatile long cursor = INITIAL_CURSOR_VALUE;
public long p8, p9, p10, p11, p12, p13, p14; // cache line padding
```

## 二、代码示例

指定并发线程数量，并发修改全局静态数据的数据，对比不同填充类型下运行同一代码逻辑的耗时

> 本示例代码样例：[ns-cn/MemPadding](https://github.com/ns-cn/MemPadding)

### 2.1 Java版本代码

> Java版本样例：[ns-cn/MemPadding/tree/main/Java](https://github.com/ns-cn/MemPadding/tree/main/Java)，依赖shell环境和JDK

提供了编译运行的脚本

```shell
./Padding [type [thread-num]]
```

|参数|说明|
|:---:|---|
|type|内存填充类型，可选(不填充选0、手动填充选1、自动填充选2)|
|thread-num|线程数量，可选，默认为10|

#### 2.1.1 不填充

并发修改的数据类型为`NoPaddingData`，除实际数据外，仅包含数据value

```java
public final static class NoPaddingData {
    public volatile long value = 0L;
}
```

以不填充的方式运行代码示例，并发线程数量为4

```shell
./Padding.sh 0 4
```

#### 2.1.2 手动填充

并发修改的数据类型为`ManualPaddingData`，除实际数据外，包含额外的手动数据填充

```java
public final static class ManualPaddingData {
    public volatile long value = 0L;
    public long p1, p2, p3, p4, p5, p6;
}
```

以手动填充的的方式运行代码示例，并发线程数量为4

```shell
./Padding.sh 1 4
```

#### 2.1.3 自动填充

并发修改的数据类型为`AutoPaddingData`，除实际数据外，
通过注解`@Contended`配合虚拟机参数`-XX:-RestrictContended`启用在运行时自动填充

```java
@Contended
public final static class AutoPaddingData {
    public volatile long value = 0L;
}
```

以手动填充的的方式运行代码示例，并发线程数量为4

```shell
./Padding.sh 2 4
```

## 三、运行结果对比

> 本结果运行环境:
>
> 硬件：MacBook Pro 15-inch, 2018（2.6 GHz 六核Intel Core i7、16GB 2400 MHz DDR4）
>
> 操作系统：Ventura 13.1
>
> JDK：1.8.0_352`OpenJDK 64-Bit Server VM (Zulu 8.66.0.15-CA-macosx) (build 25.352-b08, mixed mode)`

|方案|线程数|线程耗时|运行结果|
|---|:---:|:---:|---|
|不填充|4|45607|`170.26s user 4.40s system 382% cpu 45.700 total`|
|手动填充|4|5085|`19.21s user 0.45s system 380% cpu 5.173 total`|
|自动填充|4|5009|`19.14s user 0.43s system 383% cpu 5.102 total`|
