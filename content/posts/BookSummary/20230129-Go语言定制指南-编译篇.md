---
title: "《Go语言定制指南》-编译篇"
date: 2023-01-29T14:45:03+08:00
draft: true
tags: [BookSummary,Go]
categories: [BookSummary]
---

## 一、类型检查

> 主流的编译器前端遵循词法解析、语法解析、语义解析等流程，然后才是基于中间表示的层层优化并最终产生目标代码。`go/types`包实现对语法树的检查功能。

### 1.1 语法错误

```Go
package pkg

func hello() {
    var _ = "a" + 1
}
```

> 错误类型相加

### 1.2 go/types包

```Go
func main() {
    fset := token.NewFileSet()
    f, err := parser.ParseFile(fset, "hello.go", src, parser.AllErrors)
    if err != nil {
        log.Fatal(err)
    }

    pkg, err := new(types.Config).Check("hello.go", fset, []*ast.File{f}, nil)
    if err != nil {
        log.Fatal(err)
    }
    _ = pkg
}

const src = `package pkg

func hello() {
    var _ = "a" + 1
}
`
```

通过`new(types.Config).Check`函数检查语法树中的语义错误。

```Go
func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)
```

> 参数含义：检查包的路径、全部的文件集合（用于解析文件名和行列号）、该包中所有文件对应的语法树、存储产生的分析结果。返回`types.Package`对象

```shell
$ go run .
hello.go:4:10: cannot convert "a" (untyped string constant) to untyped int
```

### 1.3 跨包的类型检查

```Go
package main
import "math"
func main() {
    var _ = "a" + math.Pi
}
```

`go/parser`包只处理当前包, `new(types.Config).Check`方式因不知道如何加载math包校验得到如下错误

```shell
hello.go:3:8: could not import math (Config.Importer not installed)
```

`types.Config`对象的Importer成员负责导入依赖包，对于任何一个导入包都会调用Import方法加载导入信息，可使用`importer.Default()`初始化

```Go
type Config struct {
    Importer Importer
}
type Importer interface {
    Import(path string) (*Package, error)
}
```

```Go
// import "go/importer"
conf := types.Config{Importer: importer.Default()}
pkg, err := conf.Check("hello.go", fset, []*ast.File{f}, nil)
if err != nil {
    log.Fatal(err)
}
```

---

自己手动构造一个Importer实现替换默认的实现（默认实现包含标准库和用户的模块代码，还可能启动了CGO特性）

```Go
type Program struct {
    fs   map[string]string
    ast  map[string]*ast.File
    pkgs map[string]*types.Package
    fset *token.FileSet
}
func NewProgram(fs map[string]string) *Program {
    return &Program{
        fs:   fs,
        ast:  make(map[string]*ast.File),
        pkgs: make(map[string]*types.Package),
        fset: token.NewFileSet(),
    }
}
func (p *Program) LoadPackage(path string) (pkg *types.Package, f *ast.File, err error) {
    if pkg, ok := p.pkgs[path]; ok {
        return pkg, p.ast[path], nil
    }
    f, err = parser.ParseFile(p.fset, path, p.fs[path], parser.AllErrors)
    if err != nil {
        return nil, nil, err
    }
    conf := types.Config{Importer: p} // 用 Program 作为包导入器
    pkg, err = conf.Check(path, p.fset, []*ast.File{f}, nil)
    if err != nil {
        return nil, nil, err
    }
    p.ast[path] = f
    p.pkgs[path] = pkg
    return pkg, f, nil
}
func (p *Program) Import(path string) (*types.Package, error) {
    if pkg, ok := p.pkgs[path]; ok {
        return pkg, nil
    }
    pkg, _, err := p.LoadPackage(path)
    return pkg, err
}
```

> - `fs`表示每个包对应的源码字符串，`ast`表示每个包对应的语法树，`pkgs`表示经过语义检查的包对象，`fset`表示文件的位置信息
> - Import方法执行时，当`pkgs`成员没有包信息时，通过LoadPackage方法加载

使用实例

```Go
func main() {
    prog := NewProgram(map[string]string{
        "hello": `
            package main
            import "math"
            func main() { var _ = 2 * math.Pi }
        `,
        "math": `
            package math
            const Pi = 3.1415926
        `,
    })
    _, _, err := prog.LoadPackage("math")
    if err != nil {
        log.Fatal(err)
    }
    pkg, f, err := prog.LoadPackage("hello")
    if err != nil {
        log.Fatal(err)
    }
}
```

## 二、语义信息

语义分析主要时根据名字确定对象的类型和值，分析表达式的类型和值。

### 2.1 名字空间

名字空间类似于一个容器，用于存放具名的对象。

```Go
package main
import "fmt"
const Pi = 3.14
func main() {
    for i := 2; i <= 8; i++ {
        fmt.Printf("%d*Pi = %.2f\n", i, Pi*float64(i))
    }
}

----

package fmt
func Printf(format string, a ...interface{}) (n int, err error) {
    return
}
```

存在三个名字空间`main`、`fmt`和全局的宇宙空间`types.Universe`，内置的`println`/`len`等具名对象都在宇宙空间中.

> print、println、append、close、len、cap、bool、int、string

包内部的文件名字空间比较特殊，属于半封闭的名字空间。不同文件中导入包的符号时独立的，但是同一个包内的不同文件中新定义的具名对象必须在包一级是唯一的。

```Go
package main

import (
    "go/ast"
    "go/parser"
    "go/token"
    "go/types"
    "log"
    "os"
)

func init() {
    log.SetFlags(0)
}

func main() {
    prog := NewProgram(map[string]string{
        "hello.go": `
            package main

            import "fmt"

            const Pi = 3.14

            func main() {
                for i := 2; i <= 8; i++ {
                    fmt.Printf("%d*Pi = %.2f\n", i, Pi*float64(i))
                }
            }
        `,
        "fmt": `
            package fmt

            func Printf(format string, a ...interface{}) (n int, err error) {
                return
            }
        `,
    })

    pkg, _, err := prog.LoadPackage("hello.go")
    if err != nil {
        log.Fatal(err)
    }

    pkg.Scope().WriteTo(os.Stdout, 0, true)
    pkg.Scope().Parent().WriteTo(os.Stdout, 0, true)
}

type Program struct {
    fs   map[string]string
    ast  map[string]*ast.File
    pkgs map[string]*types.Package
    fset *token.FileSet
}

func NewProgram(fs map[string]string) *Program {
    return &Program{
        fs:   fs,
        ast:  make(map[string]*ast.File),
        pkgs: make(map[string]*types.Package),
        fset: token.NewFileSet(),
    }
}

func (p *Program) LoadPackage(path string) (pkg *types.Package, f *ast.File, err error) {
    if pkg, ok := p.pkgs[path]; ok {
        return pkg, p.ast[path], nil
    }

    f, err = parser.ParseFile(p.fset, path, p.fs[path], parser.AllErrors)
    if err != nil {
        return nil, nil, err
    }

    conf := types.Config{Importer: p}
    pkg, err = conf.Check(path, p.fset, []*ast.File{f}, nil)
    if err != nil {
        return nil, nil, err
    }

    p.ast[path] = f
    p.pkgs[path] = pkg
    return pkg, f, nil
}

func (p *Program) Import(path string) (*types.Package, error) {
    if pkg, ok := p.pkgs[path]; ok {
        return pkg, nil
    }
    pkg, _, err := p.LoadPackage(path)
    return pkg, err
}
```

> `pkg.Scope().WriteTo(os.Stdout, 0, true)`语句的作用时输出当前保重的名字空间信息，Go程序的每个包还有一个父名字空间可to过`pkg.Scope().Parent()`获得，宇宙空间其实也是名字空间树的根名字空间，忽略的宇宙空间的输出信息

```shell
package "hello.go" scope 0xc0000733b0 {
.  const hello.go.Pi untyped float
.  func hello.go.main()
.  hello.go scope 0xc0000734a0 {
.  .  package fmt
.  .  function scope 0xc000073a40 {
.  .  .  for scope 0xc000073a90 {
.  .  .  .  var i int
.  .  .  .  block scope 0xc000073b30 {
.  .  .  .  }
.  .  .  }
.  .  }
.  }
}
universe scope 0xc0000720a0 {
.  builtin append
.  type bool
.  type byte
.  builtin cap
.  builtin close
.  builtin complex
...
}
```

### 2.2 整体架构

- 通过`types.Sizes`对象指定极其字的宽度和对齐大小；通过`types.Importer`对象加载被导入的包
- 基于`types.Sizes`和`types.Importer`对象初始化的`types.Config`对象可以通过Check方法检查当前包的语义合法性。
- 检查完成之后，输出`*types.Package`和`*types.Info`两个对象，前者表示经过验证的包（包路径。名字以及名字空间树等信息），后者表示当前包中的所有标识符信息和引用关系

## 三、静态单赋值形式

`抽象语法树AST` -> `静态单赋值形式SSA` -> `解释执行`

### 3.1 静态单赋值形式简介

SSA通过限制变量的状态变化（单次赋值约束）来简化编译器的优化工作，几乎所有主流的编译器和计时器都提供了对SSA的支持，是一种高效的代码优化技术。`go/ssa`提供了SSA的支持。

### 3.2 生成静态单赋值

