---
title: "《精通Git 第2版》"
date: 2023-02-02T09:00:25+08:00
lastmod: 2023-02-18T16:00:25+08:00
draft: false
tags: [BookSummary,Git]
categories: [BookSummary]
url: /posts/book/9787115463067/
---

[《精通Git 第2版》](https://item.kongfz.com/book/43211068.html)

## 一、入门

### 1.1 关于版本控制

`本地` -> `集中式(例如SVN)` -> `分布式(例如Git)`

### 1.2 Git基础

<details>
<summary>快速，而非差异；几乎所有操作都在本地执行；Git的完整性；Git通常只增加数据；三种状态（已提交、已修改、已暂存）；三个主要区域（Git目录、工作目录和暂存区）</summary>

![git三个区域](https://tse2-mm.cn.bing.net/th/id/OIP-C.Y27QsYL4TKFFhD_5hT08ygHaDD?pid=ImgDet&rs=1)
</details>

### 1.3 安装Git

|安装|方式|
|---|---|
|Liunx|`yum install git-all`或`apt install git-all`|
|Mac|通过安装Xcode命令行工具安装|
|Windows|官网下载|
|源码|参考官方文档|

### 1.4 Git配置

|层级|文件位置|配置参数|
|---|---|---|
|系统级|`/etc/gitconfig`|`--system`|
|用户级|`~/.gitconfig`或`~/.config/git/config`|`--global`|
|仓库级|Git目录`.git/config`||

> Windows中查找$HOME目录中查找配置文件

配置用户身份

```shell
git config --global user.name "ns-cn"
git config --global user.email "ns-cn@qq.com"
```

配置个人编辑器，需要输入消息的时候会用到编辑器

```shell
git config --global core.editor emacs
```

检查个人配置

```shell
# 列举所有配置
git config --list
# 查看配置的用户名
git config user.name
# 查看config帮助文档
git help config
```

## 二、Git基础

### 2.1 获取Git仓库

在现有目录中初始化仓库

```shell
git init
```

克隆现有仓库

```shell
git clone https://github.com/ns-cn/ns-cn.github.io # 以仓库名为文件夹名
git clone https://github.com/ns-cn/ns-cn.github.io webroot # 以webroot为文件夹名
```

### 2.2 记录变更

查看文件状态

```shell
git status
git status -s # 显示更简介的状态信息
```

跟踪新文件 或 暂存已修改文件

```shell
git add README.md
```

通过编辑`.gitignore`文件忽略文件变更

- [ ] 空行或则以#开始的行会被忽略
- [ ] 支持标准的glob模式，*号代表0个或多个字符，[abc]代表方括号内任意单个字符，?号匹配单个
- [ ] 以/开头的模式可用于禁止递归匹配
- [ ] 以/结尾的模式表示目录
- [ ] 以感叹号开始的模式表示取反

查看已暂存和未暂存的变更

```shell
git diff # 查看暂存区和未暂存的所有变更
git diff --staged # 仅查看已暂存的变更
git diff --cached # 仅查看已暂存的变更，与--staged功能相同
```

提交变更

```shell
git commit -m "messages"
git commit -a -m "messages" # 自动把所有已跟踪的所有文件添加到暂存区然后提交
```

移除文件

```shell
rm README.md    # 删除本地文件，但未暂存变更
git rm README.md    # 删除本地文件并暂存变更
git rm -f README.md # 针对以修改并暂存了修改，必须使用-f参数强制删除
git rm --cached README.md # 暂存删除操作变更，但保留本地文件
git rm log/\*.log   # 通配符移除
```

移动文件

```shell
git mv README.md README
```

查看提交历史

```shell
git log # 所有历史
git log -p -2   # 查看最近两次提交并显示所引入的差异
git log --stat  # 查看 每个提交的简要统计信息（改动文件列表、文件数量及行数统计）
# 使用--pretty更改输出格式
git log --pretty=oneline    # 单行输出、其他short/full/fuller
git log --pretty=format:"%h - %an, %ar : %s"    # 自定义格式
git log --graph # 用ASCII字符的简单图表来显示分支和合并历史
```

> 具体的格式化格式参数参考：[git log 使用及格式化参数详解](https://blog.csdn.net/u011106915/article/details/105836289)

限制提交历史的输出范围

|选项|描述|
|---|---|
|`-(n)`|只显示最新的n次提交|
|`--since`， `--after`|只显示指定日期之后的提交|
|`--util`，`--before`|只输出指定日期之前的提交|
|`--author`|只输出指定作者与指定字符串匹配的提交|
|`--commiter`|只输出提交这与指定字符串匹配的提交|
|`--grep`|只输出提交信息包含指定字符串的提交|
|`-S`|只输出包含“添加或删除指定字符串”的更改的提交|

### 2.3 撤销操作 reset/checkout

补充提交内容或修改提交信息(只会产生一个提交记录)

```shell
git commit -m "initial commit"
git add README.md
git commit -amend   # 只会产生一次提交并补充提交暂存区内容
```

暂存区 -> 工作区

```shell
git reset HEAD <file>...
git reset HEAD --hard <file>... # 危险操作
```

撤销对文件修改（工作区保持与仓库同步，危险操作，丢失修改内容）

```shell
git checkout -- <file>...
```

> 想保留修改内容但要需要短时间使用仓库内容，可参考储藏(stash)或分支机制更好

### 2.4 远程仓库 remote

显示远程仓库

```shell
git remote  # 显示远程仓库名称
git remote -v   # 显示远程仓库和对应的url
```

添加远程仓库：`git remote add [shortname] [url]`

```shell
git remote add webroot https://github.com/ns-cn/ns-cn.github.io
```

从远程仓库获取和拉去数据： `git fetch [remote-name]`
> 会从远程仓库中获取所有本地仓库没有的数据。克隆仓库的时候会自动添加远程仓库

```shell
git fetch webroot
git pull    # 如果本地分支跟踪了远程分支，可以使用git pull
```

将数据推送到远程仓库：`git push [remote-name] [branch-name]`

```shell
git push origin master
```

检查远程仓库：`git remote show [remote-name]`

```shell
git remote show origin
```

重命名远程仓库

```shell
git remote rename pb paul
```

删除远程仓库

```shell
git remote rm paul
```

### 2.5 标记 tag

> 特定的历史版本标记为重要版本

列举标签

```shell
git tag
git tag -l "v1.8.5*"    # 通配符过滤
```

补加标签

```shell
git tag -a v1.2 9fceb02
```

共享标签：默认情况下git push不会将标签传输到远程服务器：`git push origin [tag-name]`

```shell
git push origin v1.5    # 推送指定标签到远程服务器
git push origin --tags  # 将服务器上没有的所有标签都推送
```

检出标签：无法真正检出标签，可以通过标签名称创建新的分支方式：`git checkout -b [branch-name] [tag-name]`

```shell
git checkout -b version2 v2.0.0
```

### 2.6 Git别名

通过设置git命令别名简化命令：`git config --global alias.[别名] [原始命令]`

```shell
git config --global alias.co checkout
git config --global alias.unstage 'reset HEAD --'
```

使用别名

```shell
git unstage fileA
git reset HEAD -- fileA #使用unstage等价
```

## 三、分支机制

### 3.1 分支机制

Git的分支只不过是一个指向某次提交的轻量级的可移动指针。Git的特殊指针HEAD，指向当前所在的本地分支的指针。

创建新分支

```shell
# 创建一个名为testing的新分支（创建一个指向当前提交的新指针），并未切换到新创建的分支上
git branch testing
# 查看各个分支当前所指向的对象
git log --online --decorate
```

切换分支，HEAD指针指向切换的目标分支
> 分支切换会更改工作目录文件，如果当前状态下无法干净地完成恢复操作，就不会允许你切换分支。

```shell
git checkout testing
```

> 分支实际上就是一个简单文件，其中只包含了该分支所指向提交的长度为40个字符的SHA-1校验和。

### 3.2 分支与合并操作

#### 3.2.1 直接父节点合并操作

创建并切到换对应分支增加`-b`选项

```shell
git checkout -b iss53
# 相当于
git branch iss53
git checkout iss53
```

{{< mermaid >}}
flowchart LR
    HEAD-->iss53
    master --> c2
    iss53 --> c2
    c2-->c1
    c1-->c0
{{</mermaid>}}

在iss53上提交c3

{{< mermaid >}}
flowchart LR
    master --> c2
    iss53 --> c3
    c3-->c2
    c2-->c1
    c1-->c0
{{</mermaid>}}

master分支合并iss53分支的最新修改c3

```shell
git checkout master #切换到master分支
git merge iss53     #合并iss53分支到master分支
```

{{< mermaid >}}
flowchart LR
    HEAD-->master
    master-->c3
    iss53-->c3
    c3-->c2
    c2-->c1
    c1-->c0
{{</mermaid>}}

> 直接上游合并：如果分支是待合并分支的直接上游，Git会简化直接移动指针，git称为`fast-forward`。

删除分支

```shell
git branch -d iss53
```

#### 3.2.2 不同分支节点合并

合并之前初始状态

{{< mermaid >}}
flowchart LR
    HEAD-->iss53
    master-->c4
    iss53-->c3
    c4-->c2
    c3-->c2
    c2-->c1
    c1-->c0
{{</mermaid>}}

切换到master分支并合并iss53

```shell
git checkout master #切换到master分支
git merge iss53     #合并iss53分支到master分支
```

{{< mermaid >}}
flowchart LR
    HEAD--checkout-->master
    master-->c5
    iss53-->c3
    c5--merge-->c4
    c5--merge-->c3
    c4-->c2
    c3-->c2
    c2-->c1
    c1-->c0
{{</mermaid>}}

> 三方合并：使用待合并分支的最新快照，以及共同祖先的提交快照，基于合并解构创建新的快照，再创建一个提交指向新建的快照。

#### 3.2.3 基本的合并冲突处理

修改同一文件的同一部分导致无法合并时，`git merge`不会创建提交，需要处理冲突后手动提交

### 3.3 分支管理

分支查看

```shell
git branch  #查看所有分支
git branch -v   # 查看每个分支的最新提交
git branch --merged # 筛选已合并到当前分支的所有分支
git branch --no-merged  # 筛选未合并到当前分支的所有分支
```

> 如果未合并到当前分支时对分支进行`-d`选项删除将不被允许，可使用`-D`强制删除

### 3.4 分支工作流

|分支|说明|
|---|---|
|长期分支|按稳定程度划分|
|主题分支|短期、用于实现特定功能的分支|

### 3.5 远程分支

#### 3.5.1 理解远程分支

远程分支是指向远程仓库的分支的指针，有点像输钱，提示你上一次连接服远程仓库时每个分支的位置。使用`{remote}/{branch}`表示，例如`origin/master`

> orgin并非特殊名称，与master分支名称一样

{{< mermaid >}}
flowchart LR
    subgraph clone[git clone]
    origin/master-->c2-->c1-->c0
    end
    c3-->c2
    master--git commit-->c3
    HEAD-->master
{{</mermaid>}}

`git fetch`查询远程服务器分支信息，从服务器取得本地未包含的数据，最后把`origin/master`指针移动到最新位置

```shell
git fetch origin
```

{{< mermaid >}}
flowchart LR
    subgraph fetch[git fetch]
    origin/master--git fetch-->c4
    end
    c4-->c2-->c1-->c0
    c3-->c2
    master--git commit-->c3
    HEAD-->master
{{</mermaid>}}

#### 3.5.2 推送

推送到远程分支：`git push (remote) (branch)`

```shell
git push origin test        # 简化写法，推送本地的test分支到远程的test分支
git push origin test2:test   # 完整写法，推送本地的test2分支到远程的test分支
```

> 不用每次都键入密码：基于HTTPS进行数据推送默认每次都进行身份验证，可使用`git config --global credential.helper cache`命令进行凭证缓存，暂时保存到内存几分钟。

在`git fetch`之后只是拿到了远程分支的数据，如果需要在工作区拿到这些数据，需要进行`git merge`

```shell
git fetch origin
git merge origin/test
```

#### 3.5.3 跟踪分支

跟踪分支是与远程分支直接关联的本地分支。基于远程分支创建的本地分支会自动成为跟踪分支(`tracking branch`)，或则有时候也会叫做上游分支(`upstream branch`)。

基于远程分支创建跟踪分支

```shell
git checkout --track origin/serverfix   # 切换到远程分支并自动跟踪
git branch serverfix    # 如果serverfix分支尚未创建，并且与某个远程分支名称一致，自动创建跟踪分支
git branch -b localserverfix origin/serverfix   # 基于远程分支创建并跟踪，但创建跟踪分支
```

针对已有分支设置跟踪分支，通过增加`-u`或则`--set-upstream-to`

```shell
git branch -u origin/serverfix
```

查看分支跟踪情况

```shell
git branch -vv
```

> 如果已经设置好上游分支，则可以通过`@{upstream}`或`@{u}`来使用他，例如`git merge @{u}`来代替`git merge origin/master`。

#### 3.5.4 拉取

解读`git fetch`和`git pull`命令区别

|命令|内容|结果|
|---|---|---|
|`git fetch`|拉取本地没有的远程所有最新更改数据|完全不会更改工作目录|
|`git pull`|等同于`git fetch`之后执行`git merge`|会尝试将远程分支上的修改合并到本地|

> 推荐显式使用`git fetch`之后执行`git merge`，`git pull`的机制比较迷惑。

#### 3.5.5 删除远程分支

通过`git push`的`--delete`选项删除远程分支

```shell
git push origin --delete serverfix
```

### 3.6 变基

#### 3.6.1 变基基础

变基rebase和合并merge的区别：rebase获得更加简洁的提交历史。

{{< mermaid >}}
flowchart LR
    master-->c3-->c2-->c1-->c0
    experiment-->c4-->c2
{{</mermaid>}}

在master分支上`git merge experiment`操作的结果

{{< mermaid >}}
flowchart LR
    master-->c5-->c3-->c2-->c1-->c0
    experiment-->c4-->c2
    c5-->c4
{{</mermaid>}}

在expriment分支上`git rebase master`操作的结果

{{< mermaid >}}
flowchart LR
    master-->c4[c4']-->c3-->c2-->c1-->c0
    experiment-->c4
{{</mermaid>}}

#### 3.6.2 有趣的变基操作

通过rebase部分操作到目标分支，暂不合并未经测试的内容

{{< mermaid >}}
flowchart LR
    master-->c6-->c5-->c2-->c1
    server-->c10-->c4-->c3-->c2
    client-->c9-->c8-->c3
{{</mermaid>}}

例如合并client分支但不包含c3部分到master分支

```shell
git rebase --onto master server client
```

> 命令含义：切换到client分支，找出client和server的共同祖先并提交，把client分支自共同祖先以来的所有工作在master分支重现。

{{< mermaid >}}
flowchart LR
    master-->c6-->c5-->c2-->c1
    server-->c10-->c4-->c3-->c2
    c9-->c8-->c3
    client-->c9f[c9']-->c8f[c8']-->c6
{{</mermaid>}}

接下来就可以针对master分支合并client分支

不需要切换当前分支执行变基操作可使用`git rebase [basebranch] [topicbranch]`，例如读取server变更，在master分支上重现。

```shell
git rebase master server
```

#### 3.6.3 变基操作的潜在危害

不要对已经存在于本地仓库之外的提交执行变基操作。[^变基操作的潜在危害]

[^变基操作的潜在危害]: [Git系列文章（9）：Git分支（5）](https://blog.csdn.net/LENOVOJXN/article/details/113815187)
> 变基：实际上是抛弃了已有的某些操作，随后创建了新的对应提交。

#### 3.6.4 只在需要的时候执行变基操作

`git pull --rebase`指定pull操作使用rebase方式，可使用配置修改默认方式

```shell
git config --global pull.rebase true    # git pull时默认--rebase
```

|情况|结果|
|---|---|
|变基操作用于推送前的整理和处理提交的手段，并且仅对本地还没有公开的提交进行变基|不会存在问题|
|对已经推送了的提交执行变基操作（别人已经基于提交作了自己的开发）|遇到大麻烦|

#### 3.6.5 变基与合并的对比

总结：对本地尚未推送的更改进行变基操作，从而简化提交历史，但决不能对任何已经推送到服务器的变更进行变基操作。

## 四、Git服务器

### 4.1 协议

|协议|样例|优点|缺点|
|---|---|---|---|
|本地|`git clone file:///src/project.git`|简单易用|本地网络之外的无法访问|
|HTTP|`git clone https://example.com/project.git`|账号+密码方式方便、协议速度快、传输效率高|基于HTTP的Git服务不方便搭建|
|SSH|`git clone ssh://user@server/project.git`|应用广泛、安全、传输加密|不能实现对仓库的匿名访问|
|Git||速度最快|缺少用户验证机制|

### 4.2 在服务器上搭建Git

1. 将裸仓库防止在服务器上
2. 小型团队配置（通过SSH访问）

### 4.3 GitWeb

Git自带的图形化界面

```shell
git instaweb --httpwebrick
```

### 4.4 GitLab

开源、功能完善、现代化的Git服务器软件。

|用户|组|项目|钩子|
|---|---|---|---|

## 五、分布式Git

### 5.1 分布式工作流

集中式工作流：推送变更之前都必须合并上一个人的修改（常见SVN）

{{< mermaid >}}
flowchart BT
    p1(开发人员1)-->repository[共享仓库]
    p2(开发人员2)-->repository
    p3(开发人员3)-->repository
{{</mermaid>}}

集中式管理者工作流：创建项目的公开克隆，推送自己的修改，请求主项目维护人员合并你的变更。（常见Github或GitLab）

{{< mermaid >}}
flowchart LR
    主仓库-->开发人员私有仓库-->开发人员公有仓库-->集成管理者-->主仓库
{{</mermaid>}}

司令官与副官工作流：多仓库工作流的一个变体，通常由涉及上百名协作人员的大型项目使用。

{{< mermaid >}}
flowchart LR
    主仓库-->开发人员公开仓库-->副官-->司令官-->主仓库
    主仓库-->副官
{{</mermaid>}}

### 5.2 为项目做贡献

#### 5.2.1 提交准则

1. 不要出现与空白字符相关的错误；(使用`git diff --check`鉴别并列出可能存在的空白字符错误)
2. 尽量使每次提交在逻辑上都是一个独立的变更集；(使用`git add --patch`部分暂存文件)
3. 创建高质量的提交信息。

#### 5.2.2 工作流推荐

1. 私有小团队：每次push之前先fetch+merge
2. 私有管理团队：使用分支独立管理提交内容
3. 派生的公开项目：创建fork仓库并提交变更，生成拉取请求（`pull request`）

### 5.3 维护项目

1. 使用主题分支（可为分支指定命名空间`git branch sc/ruby_client master`）
2. 应用来自电子邮件的补丁
3. 检出远程分支（将派生仓库的分支作为远程分支在本地合并）
4. 确定引入内容
   - 在分支contrib中查看排除master分支的日志：`git log contrib --not master`
   - 查看与其他分支的对比：`git diff master`
   - 查看与特定版本的对比：`git diff 36c7db`
   - 在所处分支的最新提交和两个分支的共同祖先之间进行diff操作：三点语法`git diff master...contrib`
5. 整合所贡献的工作结果：合并工作流
6. 为发布版打标签：参考[#2.5 标记tag](#25-标记-tag)
7. 生成构建编号：使用`git describe`命令为提交生成一个可读性的名称[^git_describe]
[^git_describe]: [git describe命令](https://www.yiibai.com/git/git_describe.html)
8. 准备发布：创建一个包含代码最新快照的归档文件`git archive`
9. 简报：快速得到上次发布或发送电子邮件之后新增内容的各类变更日志`git shortlog`

## 六、GitHub

略