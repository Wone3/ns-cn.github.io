---
title: "分布式缓存基于Go实现"
date: 2023-01-10T08:46:36+08:00
draft: true
tags: [BookSummary,Cache]
categories: [BookSummary]
---

《[分布式缓存-原理、架构及Go语言实现](https://item.kongfz.com/book/37765659.html)》
> 书籍参考代码[stuarthu/go-implement-your-cache-server](https://github.com/stuarthu/go-implement-your-cache-server)

---

## 第一部分：基本功能

### 一、基于HTTP的内存缓存服务

#### 1.1 Go语言实现

通过暴露HTTP/Rest接口实现对地层的缓存数据map读写

```Go
type inMemoryCache struct{
    c map[string][]byte // 缓存数据
    mutex sync.RWMutex  // 读写锁
    Stat                // 缓存状态记录
}
```

#### 1.2 与Redis对比

##### Redis持久化方案对比

|方案|说明|优点|缺点|
|---|---|---|---|
|RDB|全量的缓存快照|压缩、性能影响小、方便备份和恢复、不占用服务进程的磁盘IO|死机丢失数据多、执行RDB写入时响应慢|
|AOF|增量式保存保存所有写操作（只允许写入）|较少的数据丢失|占用磁盘空间大、AOF比RDB速度慢（较多的磁盘IO）|

##### Redis-beachmark

Redis-beachmark是Redis服务自带的性能测试工具，参数包括【并发客户端数、发起请求总数、数据长度、键的取值范围、pipline长度以及测试的类型（get/set）】

##### 对比结果

使用自实现的cache-beachmark测试inMemoryCache对比redis-beachmark测试Redis，对比结果
> Redis的rps（requests per second）大概是基于HTTP内存缓存服务的4倍：性能问题主要在于REST协议的解析。

### 二、基于TCP的内存缓存服务

#### 2.1 协议描述规范：ABNF

扩充巴科斯-瑙尔范式(ABNF)：一种基于巴科斯范式(BNF: Backus-Naur Form 的缩写)的拓展协议描述规范，基本格式`规则 = 定义 ; 注释 CR LF`，例如HTTP协议的ABNF表达式：

```text
HTTP-message=start-line *( header-filed CRLF ) CRLF [ message-body ]
start-line=request-line / status-line
request-line=method SP resquest-status SP HTTP-version CRLF
status-line=HTTP-version SP status-code SP reason-phrase CRL
header-filed=field-name ":" OWS field-value OWS
OWS=*(SP / HTAB)
field-name=token
field-value=*(field-content / obs-fold )
message-body=*OCTET
```

> 定义整体数据解构，并从后续定义每个部分的数据格式

#### 2.2 基于TCP的缓存协议规范

```text
command = op key | key-value
op = 'S' | 'G' | 'D'
key = bytes-array
length = 1*DIGIT
content = *OCTET
key-value = length SP length SP content content
response = error | bytes-array
error = '-' bytes-array
```

解读：整体为一个操作类型接键或键值对
|操作|说明|请求协议|实例|
|---|---|---|---|
|SET|设置值|`S<klen><SP><vlen><SP><key><value>`|`S4 6 namewangwu`|
|GET|获取值|`G<klen><SP><key>`|`G4 name`|
|DEL|删除键|`D<klen><SP><key>`|`D4 name`|
||错误响应|`-<elen><err>`|`-8NOTFOUND`|
||正常响应|`<vlen><value>`|`6wangwu`|

#### 2.3 Go语言实现

根据协议读取数据,并响应执行结果，如果出错则中断TCP链接

> 使用cach-beanchmark测试基于TCP的缓存服务是基于HTTP的2倍

### 三、基于RocksDB数据持久化

#### 3.1 Go语言本地调用机制：CGO

Go语言提供的机制，可用于调用C的API函数，类似于Java语言提供的JNI等，例如

```Go
package main
// #include "test.h"
// #cgo LDFLAGS: libtest.a -lstdc++
import "C"
func main(){
    C.test()
}
```

#### 3.2 RocksDB

Facebook基于LevelDB完全使用C++开发，可以在纯内存、闪存、机械硬盘或HDFS等环境使用

> Github地址：[facebook/rocksdb](https://github.com/facebook/rocksdb/)

#### 3.3 Go语言实现

通过cgo调用RocksDB的库文件实现对RocksDB的读写
> 需要注意Go自动GC，而C++需要手动管理内存，例如

```Go
func main(){
    k := C.CString("name") // Go的字符串转C语言的char*
    defer C.free(unsafe.Pointer(k)) // 手动释放内存
    key := C.GoString(k) // C语言的char*转Go语言的字符串
}
```

---

## 第二部分：性能部分

### 四、用pipelining加速性能

#### 4.1 pipelining原理

在不改变服务端实现的情况下，加速客户端性能

|方式|N请求耗时|简介||
|---|---|---|---|
|no pipelining|N*SRT|N个请求逐个完成|
|pipelining|R+S+N*P|一次发送所有请求，服务端逐个处理并响应|

> SRT:（send retrun process，也有做RTT（round-trip time）），一个完整的请求耗时，包含发送、返回和处理耗时

![pipelining对比](https://ask.qcloudimg.com/http-save/1560260/gof3wnshff.png?imageView2/2/w/1620)

#### 4.2 拓展阅读：[HTTP中的pipelining](https://cloud.tencent.com/developer/article/1388131)

HTTP/1.0中链接无状态、无法复用，HTTP/1.1以后支持pipelining

- 只有幂等请求(GET/HEAD)能使用pipelining，非幂等请求（例如POST）不能使用
- 请求必须依次返回，遵循FIFO，导致后续请求被阻塞
- 绝大多数http代理服务器不支持pipelining
- 和不支持pipelining的老服务器协商有问题

HTTP/2协议定义更接近TCP，通过StreamID进行流控制，从而解决HTTP/1.1中必须顺序返回的问题

#### 4.3 Redis中的pipelining

一次请求/响应服务器能实现处理新的请求，即使旧请求还未被响应。这样即可将多个命令发送到服务器，而不用等待响应，最后在一个步骤中读取该响应。即管道（pipelining），许多POP3协议支持该功能，大大加快从服务器下载新邮件的过程。

例如使用`nc`进行TCP请求

```shell
$ (printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379
+PONG
+PONG
+PONG
```

也可以使用`redis-beachmark`的`-P`参数指定pipeline长度来实现该redis的pipelining功能测试

#### 4.4 Go语言实现

服务端循环执行命令解析，并顺序写入响应结果

```Go
// 伪代码
for{
    command := connection.ReadCommand()
    result := command.Execute()
    connection.WriteResponse(result)
}
```

或则通过分离读取和写入实现异步读取和写入

```Go
resultChan = make(chan result, maxPipelineNum)
// 读取操作
for{
    command := connection.ReadCommand()
    result := command.Execute()
    resultChan <- result
}
// 写入操作
go fun(){
    for{
        result := <-resultChan
        connection.WriteResponse(result)
    }
}()
```

> 这种实现是命令阻塞式的

### 五、批量写入

#### 5.1 批量写入提升性能原理

> pipelining从客户端角度提升性能，批量写入从服务端角度提升性能

将收到的写入请求积攒起来一次写入，提升效率体现在如下三个方面

- 减少磁盘寻道和旋转延时提升磁盘IO效率
- 写入内容放到连续内存减少CPU载入的次数和CPU内多级缓存失效
- 缓存的Set操作现在可以尽快返回而步兵等待磁盘操作结果

批量写入的缺点：

- 不再可以知晓每一次缓存Set操作的真实结果，无法细分操作的错误
- Set操作还在执行队列而未实际缓存就被访问

#### 5.2 Go语言实现

两种方式触发批量写入，命令队列或则定时器，如果从队列中读取到或定时器触发且有待写入的，则执行批量写入

```Go
writeChan := make(chan request, maxSize);
t := time.NewTimer(time.Second)
for{
    select{
    case p := <-c:
        writeBatch(p)
        t.Reset(time.Second)
    case <-t.C:
        flushBatch(data)
        t.Reset(time.Second)
    }
}
```

### 六、异步操作

#### 6.1 批量读取的可能性

RocksDB提供了批量读取(MultiGet)的功能，但受限于如下原因在API层面和是否批量没有太大差别

- 内部存储使用静态排序表SST，但批量读取的键并不跟SST顺序一致，始终需要在SST中查询每个单独的键

#### 6.2 异步操作提升性能原理

异步处理同一个TCP连接的请求，处理完成先后顺序与开始顺序不一致，响应顺序由协议制定者确定。

- 类似HTTP/1.1处理pipelining保持先进先出
- 类似HTTP/2保持完成顺序返回

> 本书采用先进先出的顺序

#### 6.3 Go语言实现

针对每个请求建立响应channel队列和异步响应处理结果，

1. 处理每个请求异步处理得到得到返回响应channel并放到响应队列；
2. 异步处理完成将结果写入对应的队列；
3. 异步监听响应队列，从每个队列取出响应channel并读取响应结果并返回响应

> 其中1和2保证异步处理能力，3保证顺序响应先进先出

```Go
// 大致逻辑代码如下
func process(conn net.Conn){
    resultCh := make(chan chan *result, 5000)
    defer close(resultCh)
    go reply(conn, resultCh)            // 异步响应所有的处理结果
    for{
        cmd := readCommand(conn)        // 逐个读取命令
        result := make(chan *result)    // 命令执行的响应结果队列
        resultCh <- result              // 顺序将结果队列放到响应队列
        go func(){
            result <- executeCommand(cmd)   // 异步执行命令并将响应结果放到响应队列
        }()
    }
}
```

---

## 第三部分：服务集群
