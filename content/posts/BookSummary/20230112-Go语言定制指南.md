---
title: "《Go语言定制指南》"
date: 2023-01-12T10:02:35+08:00
draft: false
tags: [BookSummary,Go]
categories: [BookSummary]
---

《[Go语言定制指南](https://item.kongfz.com/book/49334060.html)》

## 一、词法单元

高级语言由许多基本元素构成，基本元素就是词法单元。词法单元构成表达式和语句；表达式和语句构成函数；函数构成源文件；源文件构成软件工程项目。

词法单元三个重要属性：类型、在源代码中的原始文本形式、出现的位置。（特殊的注释和分号可忽略）

### 1.1 词法单元简介

Go语言中的词法单元分为标识符（包括25个关键字）、运算符和分隔符等几类。

|自定义标识符|25个关键字|47个运算符和分隔符|字面量|注释|空白符|
|---|---|---|---|---|---|---|

```ABNF
identifier = letter { letter | unicode_digit } .
letter     = unicode_letter | "_" .
```

### 1.2 Token定义

```Go
type token int
```

源代码参考`go/token`包中的`token.Token`枚举表示，分为特殊类型、基础字面量、操作符和关键字大类。

|类别|举例|
|---|---|
|特殊类型|错误ILLEGAL、EOF文件结束、注释COMMENT|
|基础字面量|IDENT、INT、FLOAT、IMAG、CHAR、STRING|
|操作符|ADD、SUB、MUL...|
|关键字|BREAK、CASE、CHAN、CONST...|

> 各种大类之间有枚举值表示开始和结束，用于判断具体类型属于哪个大类，例如`literal_beg`和`literal_end`之间的都属于字面量类型。

解读：

- 基础字面量仅包含整数、浮点数、复数、符文和字符串，不包含true和false。
- 运算符：算数运算符、逻辑运算符、位运算符和比较运算符、取址运算符、管道运算符等；分隔符：圆括号、花括号、方括号、逗号、圆点、分号和冒号。

### 1.3 FileSet和File

每个FileSet表示一个文件集合，底层抽象为一个一维数组，而Pos类型表示数组的下标位置。FileSet中的每个File元素对应底层数组的一个区间，不同的File之间没有交集，相邻的File之间可能存在填充空间。

![FileSet和File对象的对应关系](https://github.com/chai2010/go-ast-book/raw/master/images/ch1-file-set-01.ditaa.png)

File的组成
|文件名|base|size|
|:---:|:---:|:---:|
|文件名|对应File在FileSet中的Pos索引位置|文件大小|

File内部通过`offset`定位下标索引，通过`File.base+offset`可以将内部的offset转换为FileSet的Pos位置。

### 1.4 解析Token 

使用标准库的`go/scanner.Scanner`实现Token扫描，包含Init方法和Scan方法，Init指定目标文件、源码字节、错误处理和扫描模式；Scan方法逐个扫描得到具体位置、词法单元和原始字符串

```Go
type Scanner struct {
    ErrorCount int // number of errors encountered
}
func (s *Scanner) Init(
    file *token.File, src []byte,
    err ErrorHandler, mode Mode,
)
func (s *Scanner) Scan() (
    pos token.Pos, tok token.Token, lit string,
)
```

使用样例

```Go
package main
import (
    "fmt"
    "go/scanner"
    "go/token"
)
func main() {
    var src = []byte(`println("你好，世界")`)
    var fset = token.NewFileSet()
    var file = fset.AddFile("hello.go", fset.Base(), len(src))
    var s scanner.Scanner
    s.Init(file, src, nil, scanner.ScanComments)
    for {
        pos, tok, lit := s.Scan()
        if tok == token.EOF {
            break
        }
        fmt.Printf("%s\t%s\t%q\n", fset.Position(pos), tok, lit)
    }
}
```

```shell
hello.go:1:1    IDENT   "println"
hello.go:1:8    (       ""
hello.go:1:9    STRING  "\"你好，世界\""
hello.go:1:26   )       ""
hello.go:1:27   ;       "\n"
```

### 1.5 Position位置信息

`go/token.Position`表示更详细的位置信息，`fset.Position(pos)`可获得对应位置的信息。

## 二、基础字面量

### 2.1 基础面值

#### 2.1.1 定义

例如整数的定义（十进制、二进制、八进制和十六进制）

```ABNF
int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .
decimal_lit    = "0" | ( "1" … "9" ) [ [ "_" ] decimal_digits ] .
binary_lit     = "0" ( "b" | "B" ) [ "_" ] binary_digits .
octal_lit      = "0" [ "o" | "O" ] [ "_" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "_" ] hex_digits .
```

> 完整定义参考[基础面值定义](https://github.com/chai2010/go-ast-book/blob/master/ch2/readme.md#21-%E5%9F%BA%E7%A1%80%E9%9D%A2%E5%80%BC%E5%AE%9A%E4%B9%89)

#### 2.1.2 基础面值语法树结构

`go/ast.BasicLit`表示一个基础类型的面值常量结构，开始的字节偏移量、面值类型和原始代码字符串

```Go
type BasicLit struct {
    ValuePos token.Pos   // literal position
    Kind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING
    Value    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`
}
```

#### 2.1.3 手动构造面值

```Go
package main
import (
    "go/ast"
    "go/token"
)
func main() {
    var lit9527 = &ast.BasicLit{
        Kind:  token.INT,
        Value: "9527",
    }
    ast.Print(nil, lit9527)
}
```

#### 2.1.4 解析基础面值

使用`go/parser.PaseExpr`函数解析

```Go
func main() {
    expr, _ := parser.ParseExpr(`9527`)
    ast.Print(nil, expr)
}
```

```shell
0  *ast.BasicLit {
1  .  ValuePos: 1
2  .  Kind: STRING
3  .  Value: "\"9527\""
4  }
```

> 通过基础面值、指针、结构体、数组和map等其他语法解构的互相嵌套可以构造其他复杂类型。

### 2.2 标识符面值

#### 2.2.1 结构

```Go
type Ident struct {
    NamePos token.Pos // identifier position
    Name    string    // identifier name
    Obj     *Object   // denoted object; or nil
}
```

#### 2.2.2 手动构造

```Go
func main() {
    ast.Print(nil, ast.NewIdent(`x`))
}
```

#### 2.2.3 解析标识符面值

```Go
func main() {
    ast.Print(nil, ast.NewIdent(`x`))
}
```

```shell
0  *ast.Ident {
1  .  NamePos: 1
2  .  Name: "x"
3  .  Obj: *ast.Object {
4  .  .  Kind: bad
5  .  .  Name: ""
6  .  }
7  }
```

> `ast.Object`是一个相对复杂的结构，其中Kind用于描述标识符的类型，`Bad`表示未知的类型

## 三、基础表达式

基础表达式是指完全由数值型面值和标识符组成的表达式。

### 3.1 基础表达式语法

```ABNF
Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = Operand | unary_op UnaryExpr .
Operand    = Literal | identifier | "(" Expression ")" .

binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
```

> 其中Expression表示基础表达式的递归定义，可以是UnaryExpr类型的一元表达式，或者是binary_op生成的二元表达式。而基础表达式运算符两边的对象由Operand定义，主要是面值或表达式，也可以是由小括弧包含的表达式。

### 3.2 解析表达式

`parser.ParseExpr`函数解析返回`ast.Expr`抽象接口

```Go
type Expr interface {
    Node
    // contains filtered or unexported methods
}
type Node interface {
    Pos() token.Pos // position of first character belonging to the node
    End() token.Pos // position of first character immediately after the node
}
```

具体表达式类型

```shell
$ go doc go/ast | grep Expr
type BadExpr struct{ ... }
type BinaryExpr struct{ ... }
type CallExpr struct{ ... }
type Expr interface{ ... }
type ExprStmt struct{ ... }
type IndexExpr struct{ ... }
type KeyValueExpr struct{ ... }
type ParenExpr struct{ ... }
type SelectorExpr struct{ ... }
type SliceExpr struct{ ... }
type StarExpr struct{ ... }
type TypeAssertExpr struct{ ... }
type UnaryExpr struct{ ... }
```

解析代码实例

```Go
func main() {
    expr, _ := parser.ParseExpr(`1+2*3`)
    ast.Print(nil, expr)
}
```

![抽象语法树](https://github.com/chai2010/go-ast-book/raw/master/images/ch3-expr-01.png)

其中`ast.BinaryExpr`表示二元表达式的节点，包含两个Expr类型的操作数（可递归）、以及Token类型的操作符

```Go
type BinaryExpr struct {
    X     Expr        // left operand
    OpPos token.Pos   // position of Op
    Op    token.Token // operator
    Y     Expr        // right operand
}
```

### 3.3 表达式求值

基础字面量`ast.BasicLit`是特殊的表达式，如果是二元表达式则根据操作符将操作数进行对应的求值

```Go
func main() {
    expr, _ := parser.ParseExpr(`1+2*3`)
    fmt.Println(Eval(expr))
}
func Eval(exp ast.Expr) float64 {
    switch exp := exp.(type) {
    case *ast.BinaryExpr:
        return EvalBinaryExpr(exp)
    case *ast.BasicLit:
        f, _ := strconv.ParseFloat(exp.Value, 64)
        return f
    }
    return 0
}
func EvalBinaryExpr(exp *ast.BinaryExpr) float64 {
    switch exp.Op {
    case token.ADD:
        return Eval(exp.X) + Eval(exp.Y)
    case token.MUL:
        return Eval(exp.X) * Eval(exp.Y)
    }
    return 0
}
```

### 3.4 带变量的表达式求值

标识符`ast.Indent`也是表达式，，在求值是带上一个上下文参数，从上下文中获取对应标识符的变量值，进行求值

```Go
func main() {
    expr, _ := parser.ParseExpr(`1+2*3+x`)
    fmt.Println(Eval(expr, map[string]float64{
        "x": 100,
    }))
}
func Eval(exp ast.Expr, vars map[string]float64) float64 {
    switch exp := exp.(type) {
    case *ast.BinaryExpr:
        return EvalBinaryExpr(exp, vars)
    case *ast.BasicLit:
        f, _ := strconv.ParseFloat(exp.Value, 64)
        return f
    case *ast.Ident:
        return vars[exp.Name]
    }
    return 0
}
func EvalBinaryExpr(exp *ast.BinaryExpr, vars map[string]float64) float64 {
    switch exp.Op {
    case token.ADD:
        return Eval(exp.X, vars) + Eval(exp.Y, vars)
    case token.MUL:
        return Eval(exp.X, vars) * Eval(exp.Y, vars)
    }
    return 0
}
```

## 四、代码结构

### 4.1 目录结构

`parser.ParseDir`解析目录内的全部Go语言文件，`parser.ParseFile`解析单个文件

![ParseDir和ParseFile](https://github.com/chai2010/go-ast-book/raw/master/images/ch4-file-struct-01.png)

> _test为后缀会自动生成独立的测试包

### 4.2 文件结构

源文件由包定义、导入声明和顶级声明三个部分组成

```ABNF
SourceFile    = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .

PackageClause = "package" PackageName .
PackageName   = identifier .

ImportDecl    = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
ImportSpec    = [ "." | PackageName ] ImportPath .
ImportPath    = string_lit .

TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
Declaration   = ConstDecl | TypeDecl | VarDecl .
```

使用`parser.ParseFile`解析单个文件实例

```Go
func main() {
    fset := token.NewFileSet()
    f, err := parser.ParseFile(fset, "hello.go", src, parser.AllErrors)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("package:", f.Name)
    for _, s := range f.Imports {
        fmt.Println("import:", s.Path.Value)
    }
    for _, decl := range f.Decls {
        fmt.Printf("decl: %T\n", decl)
    }
}
const src = `package pkgname
import ("a"; "b")
type SomeType int
const PI = 3.14
var Length = 1
func main() {}
`
```

返回的类型为`*ast.File`类型，其中import、type、const和var都对应*ast.GenDecl类型，函数是独立的*ast.FuncDecl类型

```Go
type File struct {
    Doc        *CommentGroup   // associated documentation; or nil
    Package    token.Pos       // position of "package" keyword
    Name       *Ident          // package name
    Decls      []Decl          // top-level declarations; or nil
    Scope      *Scope          // package scope (this file only)
    Imports    []*ImportSpec   // imports in this file
    Unresolved []*Ident        // unresolved identifiers in this file
    Comments   []*CommentGroup // list of all comments in the source file
}
```